= Relationships and links

Version: 0.1.0

== Overview

Features can have properties that are relationships with other features or resources like codelists, etc. There are multiple options how to encode such relationships and JSON-FG could provide guidance how to represent such relationships.

Relationships will often be direct properties of the feature, but they may also occur in embedded JSON objects.

Like all other properties, properties that are relationships may have a maximum multiplicity greater than one. That is, the JSON representation may be an array of relationships.

This page is not yet a full proposal, but documents options how to represent relationships and links. It is unclear, if we can or should do more.

== Examples

In this discussion a cadastral parcel feature is used as the sample feature resource. The hypothetical parcel has the following properties: 

* a (multi-)polygon geometry (ignored in the JSON examples to keep the examples short);
* a parcel identifier ("foo");
* its area (2000 square meters);
* a set of ownership records (two owners, each with 50% share);
* a set of buildings on the parcel (one building on the parcel);
* information about land use (using a national classification system) and the area for each applicable land use type (500 square meters with residential use, 1500 square meters with commercial use).

The owners, buildings and land use types are web resources, too, and have URIs as identifiers.

Three alternatives for representing relationships with other features or resources are discussed below. They all address different use cases.

=== Option 1: Add all relationships to a "links" member of the JSON object that is the link anchor

This option is consistent with the general approach in the OGC API standards. It uses Web linking and a consistently named JSON member with an array of OGC API Link objects.

The semantics of the relationship / association role is expressed via the link relation type. Where possible, link relation types registered with IANA or OGC should be used, but the data publisher can also define their own link relation types. Note that this introduces overhead, because it requires minting persistent URIs for the link relation types. Where this is too much, an existing link relation type should be used and "related" could be used as a fallback.

Note that the examples use Safe CURIEs as [proposed in the OGC-NA discussions](https://github.com/opengeospatial/NamingAuthority/issues/92#issuecomment-888186821) in cases where the link relation type is a URI.

The parcel feature could looks like the following example. The building relationship has been mapped to a hypothetical "http://www.opengis.net/def/rel/ogc/1.0/contains" link relationship based on the topological relationship "contains" from the Simple Features standard.

.Option 1: use "links" members
[%collapsible]
====
[source,json]
----
{
   "type":"Feature",
   "geometry": null,
   "links" : [ { 
      "rel" : "[contains]",
      "title" : "123 Main St., Atlantis",
      "href" : "https://example.com/building/123"
   } ],
   "properties": {
      "registerId": "foo",
      "area_m2": 2000,
      "owners": [ {
         "share_%": 50,
         "links": [ { 
            "href": "https://example.com/person/foo", 
            "title": "John Doe", 
            "rel": "[app:owner]" 
         } ],
      }, {
        "share_%": 50,
         "links": [ { 
            "href": "https://example.com/company/bar", 
            "title": "Acme Inc", 
            "rel": "[app:owner]" 
         } ],
      } ],
      "use": [ {
         "area_m2": 500,
         "links": [ { 
            "href": "https://example.com/landuse/residential", 
            "title": "residential use", 
            "rel": "[app:land-use]" 
         } ]
      }, {
        "area_m2": 1500,
         "links": [ { 
            "href": "https://example.com/landuse/commercial", 
            "title": "commercial use", 
            "rel": "[app:land-use]" 
         } ]
      } ]
   }
}
----
====

A variation of this approach would be to separate the API navigation links ("links") from the feature properties and place those links in another member (e.g. "associations").

Another variation could be to put all links in the top-level "links" array, but add explicit link anchors for those links that do not have the document URI as the anchor.

.Option 1b: use only the top-level "links" member
[%collapsible]
====
[source,json]
----
{
   "type":"Feature",
   "geometry": null,
   "links" : [ { 
      "rel" : "[contains]",
      "title" : "123 Main St., Atlantis",
      "href" : "https://example.com/building/123"
   }, {
      "anchor": "#/properties/owners/0", 
      "href": "https://example.com/person/foo", 
      "title": "John Doe", 
      "rel": "[app:owner]" 
   }, {
      "anchor": "#/properties/owners/1", 
      "href": "https://example.com/company/bar", 
      "title": "Acme Inc", 
      "rel": "[app:owner]" 
   }, {
      "anchor": "#/properties/landUse/0", 
      "href": "https://example.com/landuse/residential", 
      "title": "residential use", 
      "rel": "[app:land-use]" 
   }, {
      "anchor": "#/properties/landUse/1", 
      "href": "https://example.com/landuse/commercial", 
      "title": "commercial use", 
      "rel": "[app:land-use]" 
   } ],
   "properties": {
      "registerId": "foo",
      "area_m2": 2000,
      "owners": [ 
         { "share_%": 50 },
         { "share_%": 50 } 
      ],
      "use": [ 
         { "area_m2": 500 },
         { "area_m2": 1500 }
      ]
   }
}
----
====

=== Option 2: Encode links like other feature properties - using a simplified link object

This option treats the relationships like other properties and uses a simplified OGC API Link object without a "rel" attribute, since the semantics of the link is already expressed by the property. 

A variation could be to require the use of a valid link relation type as the key of the JSON member, which would basically move the link relation type to a key to group all links with the same link relation type.

.Option 2: Encode as feature properties with a link object as the value
[%collapsible]
====
[source,json]
----
{
   "type":"Feature",
   "geometry": null,
   "properties": {
      "registerId": "foo",
      "area_m2": 2000,
      "buildings": [ {
         "title" : "123 Main St., Atlantis",
         "href" : "https://example.com/building/123"
      } ],
      "owners": [ {
         "share_%": 50,
         "owner": { 
            "href": "https://example.com/person/foo", 
            "title": "John Doe"
         }
      }, {
         "share_%": 50,
         "owner": { 
            "href": "https://example.com/company/bar", 
            "title": "Acme Inc"
         }
      } ],
      "use": [ {
         "area_m2": 500,
         "landUse": { 
            "href": "https://example.com/landuse/residential", 
            "title": "residential use"
         }
      }, {
         "area_m2": 1500,
         "landUse": { 
            "href": "https://example.com/landuse/commercial", 
            "title": "commercial use"
         }
      } ]
   }
}
----
====

A variation of this option would be to flatten the link objects. I.e., instead of

====
[source,json]
----
   "owner": { 
      "href": "https://example.com/company/bar", 
      "title": "Acme Inc"
   }
----
====

the link could be encoded as

====
[source,json]
----
   "owner.href": "https://example.com/company/bar", 
   "owner.title": "Acme Inc"
----
====

=== Option 3: Only use the URI

This option is similar to option 2, but the link objects are reduced to the href value. As a result, this option is more concise, but it lacks information that would be useful for the human (unless the URIs are dereferenced to fetch a label/title). In addition, since this approach does not use web linking according to RFC 8288, no link relation types for the links are available.

.Option 3: Encode as feature properties with a URI
[%collapsible]
====
[source,json]
----
{
   "type":"Feature",
   "geometry": null,
   "properties": {
      "registerId": "foo",
      "area_m2": 2000,
      "buildings": [ 
         "https://example.com/building/123"
      ],
      "owners": [ {
         "share_%": 50,
         "owner": "https://example.com/person/foo"
      }, {
         "share_%": 50,
         "owner": "https://example.com/company/bar"
      } ],
      "use": [ {
         "area_m2": 500,
         "landUse": "https://example.com/landuse/residential"
      }, {
         "area_m2": 1500,
         "landUse": "https://example.com/landuse/commercial"
      } ]
   }
}
----
====

== Description

Option 1 seems best suited, if the intended use of the data benefits from a consistent place where links are included in the JSON document.

Option 2 seems best suited, if the JSON features should closely reflect the application schema of the features (if there is one).

The same applies to option 3, too, but this option seems mainly useful in combination with JSON-LD. Also, the information is not sufficient to render a useful HTML representation from the JSON representation without fetching the linked resources.

Depending on the data and how the data is expected to be used, the preferences of data publishers for one or the other option will vary.

== Discussion, Alternatives, References

=== Embedding features or other objects

The related resources can be referenced or embedded in the feature representation (embedding is only sensible, if the resource can be represented as a JSON object). This proposal only discusses the case where a related resource is referenced and where the related resources are web resources, i.e. resources that are identified by HTTP(S) URIs. If resources are embedded, they will be embedded as a value in a member in the "properties" object.

=== The OGC API "links" member

A GeoJSON feature that is encoded by a Web API implementing OGC API standards will often already include a "links" member with an array of OGC API Link objects. The OGC API Link object is a JSON implementation of web links according to RFC 8288. As discussed above, the OGC API Features standard currently only specifies requirements for links to resources in the API to support clients navigating the API.

=== Are links part of the resource or metainformation?

There is a general, somewhat philosophical discussion topic related to links between resources.

In general, the links of a web resource are considered metainformation, and strictly the links do not have to be part of the cachable representations of the resource. RFC 8288 (Web linking) supports this by supporting that links are only represented as HTTP headers, outside of the representations. Changes to a link would not impact the ETag or Last-Modified headers of the resource.

The standard links in feature (collection) resources specified in OGC API Features ("self", "alternate", "next", "collection") or in JSON Schema ("describedby") are a good example. A change in any of those links does not indicate a change in the resource itself, but it indicates a technical change in the implementation. For example, another alternate representation has been added or the schema has moved to a different URI.

However, because the OGC API standards include the links in the JSON representation - like most of the existing approaches to JSON-based Web APIs, a change in the links will also invalidate cached representations of the resource (and update the ETag and Last-Modified headers). It has been a conscious decision to include the links in the JSON representation, because this seems to meet the expectations of developers today.

The same applies to many of the explicit or implicit relationships that are expressed in geospatial datasets today. Whether a second building is erected on the parcel or not does not really change the parcel. It could be argued, that the relationship between the parcel and the building is metainformation and a change to a relation does not change the parcel - and should not invalidate any cached representations. Links between the resources could be managed - and accessed - as separate resources (e.g. linksets). 

Nevertheless, many users and developers will prefer a more "traditional" way of sharing geospatial features with relationships included in the resource representation and the discussion below is based on this assumption.

=== Link relation types for spatial topological relationships

Link relation types for the topological interval relationships as specified in OWL Time are already registered with IANA. The registration of the named spatial topological relationships should be considered, either in the IANA or the OGC register.

=== Querying links

An extension to CQL2 to properly support filtering links should be considered by OGC API Features, too.
